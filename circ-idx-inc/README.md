1. Начать с инициализации переменной индекса: **zero** или **one**.
2. Выполнить итерацию.
3. Инкремент индекса:
    - **zero-based**: ```+1``` потом ```%N```
    - **one-based**: ```%N``` потом ```+1```

3 пункт запомнить легко, если подумать о предпоследней и последней итерации,
на которой индекс содержит максимально возможное значение,
что нужно сделать чтобы вернуться к исходному значению на следующей итерации
не выходя в процессе вычислений за пределы ```N```?

Пример, если N = 10

- **zero-based**: ```(9 + 1) % 10 = 0```
- **one-based**: ```(10 % 10) + 1 = 1```

На последней итерации способ для **zero-based** применим и для **one-based**, но не наоборот.

- **zero-based**: ```(9 % 10) + 1 = 10``` - выход за границы массива!
- **one-based**: ```(10 + 1) % 10 = 1``` - верно, но результат промежуточного вычисления в скобках ```> N```

Однако на предпоследней итерации это не так.

- **zero-based**: ```(8 % 10) + 1 = 9``` - следющий индекс верен
- **one-based**: ```(9 + 1) % 10 = 0``` - выход за границы массива!

До предпоследнего индекса (не включительно) обе формулы работают:

| base | zero               | one                |
| ---- | ------------------ | ------------------ |
|  0   |  (0 + 1) % 10 = 1  |  (0 % 10) + 1 = 1  |
|  1   |  (1 + 1) % 10 = 2  |**(1 % 10) + 1 = 2**|
|  2   |  (2 + 1) % 10 = 3  |  (2 % 10) + 1 = 3  |
|  3   |  (3 + 1) % 10 = 4  |  (3 % 10) + 1 = 4  |
|  4   |  (4 + 1) % 10 = 5  |  (4 % 10) + 1 = 5  |
|  5   |  (5 + 1) % 10 = 6  |  (5 % 10) + 1 = 6  |
|  6   |  (6 + 1) % 10 = 7  |  (6 % 10) + 1 = 7  |
|  7   |  (7 + 1) % 10 = 8  |  (7 % 10) + 1 = 8  |
|  8   |  (8 + 1) % 10 = 9  |  (8 % 10) + 1 = 9  |
|  9   |**(9 + 1) % 10 = 0**|  (9 % 10) + 1 = 10 |
| 10   | (10 + 1) % 10 = 1  | (10 % 10) + 1 = 1  |
